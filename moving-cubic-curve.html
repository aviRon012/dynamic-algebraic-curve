<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cubic Curve Regions</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a;
            font-family: sans-serif;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #glCanvas {
            z-index: 0;
        }
        #uiCanvas {
            z-index: 1;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <canvas id="uiCanvas"></canvas>

    <script>
        // --- CONFIG ---
        const POINT_COUNT = 9;
        const POINT_RADIUS = 6;
        const MIN_DISTANCE = 100;
        const MAX_SPEED = 2.5; 
        const MAX_FORCE = 0.15;   
        const WANDER_STRENGTH = 0.1;

        const COLOR_POS = [30/255, 41/255, 59/255, 1.0]; 
        const COLOR_NEG = [15/255, 23/255, 42/255, 1.0];
        const COLOR_LINE = [45/255, 212/255, 191/255, 1.0];
        const POINT_COLOR = '#5eead4';

        // --- VECTOR ---
        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            set(x, y) { this.x = x; this.y = y; return this; }
            setVec(v) { this.x = v.x; this.y = v.y; return this; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { if (n !== 0) { this.x /= n; this.y /= n; } return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() { let m = this.mag(); if (m > 0) this.div(m); return this; }
            limit(max) { if (this.mag() > max) { this.normalize(); this.mult(max); } return this; }
            static dist(v1, v2) { let dx = v1.x - v2.x; let dy = v1.y - v2.y; return Math.sqrt(dx * dx + dy * dy); }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
            copy() { return new Vector(this.x, this.y); }
        }

        // --- PARTICLE ---
        class Particle {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.vel = new Vector(Math.random() * 2 - 1, Math.random() * 2 - 1);
                this.acc = new Vector(0, 0);
                this.wanderTheta = Math.random() * Math.PI * 2;
                
                // Reusable vectors to reduce GC
                this._steer = new Vector(0, 0);
                this._diff = new Vector(0, 0);
                this._circleCenter = new Vector(0, 0);
                this._displacement = new Vector(0, 0);
            }

            applyForce(force) { this.acc.add(force); }

            separate(particles) {
                let desiredseparation = MIN_DISTANCE;
                this._steer.set(0, 0);
                let count = 0;
                for (let other of particles) {
                    let d = Vector.dist(this.pos, other.pos);
                    if ((other !== this) && (d < desiredseparation)) {
                        this._diff.setVec(this.pos).sub(other.pos);
                        this._diff.normalize();
                        this._diff.div(d);
                        this._steer.add(this._diff);
                        count++;
                    }
                }
                if (count > 0) {
                    this._steer.div(count);
                    this._steer.normalize();
                    this._steer.mult(MAX_SPEED);
                    this._steer.sub(this.vel);
                    this._steer.limit(MAX_FORCE * 1.5);
                }
                return this._steer;
            }

            wander() {
                let wanderRange = 0.3;
                this.wanderTheta += (Math.random() * 2 - 1) * wanderRange;
                let wanderRadius = 25;
                let wanderDistance = 80;
                
                this._circleCenter.setVec(this.vel);
                this._circleCenter.normalize();
                this._circleCenter.mult(wanderDistance);
                
                this._displacement.set(0, -1);
                this._displacement.mult(wanderRadius);
                
                let h = this.wanderTheta;
                let x = this._displacement.x;
                let y = this._displacement.y;
                this._displacement.x = x * Math.cos(h) - y * Math.sin(h);
                this._displacement.y = x * Math.sin(h) + y * Math.cos(h);
                
                let target = this._circleCenter.add(this._displacement);
                target.limit(MAX_FORCE);
                return target;
            }

            edges(width, height) {
                let margin = 50;
                let steer = this._diff;
                steer.set(0, 0);
                
                if (this.pos.x < margin) steer.x = MAX_SPEED;
                if (this.pos.x > width - margin) steer.x = -MAX_SPEED;
                if (this.pos.y < margin) steer.y = MAX_SPEED;
                if (this.pos.y > height - margin) steer.y = -MAX_SPEED;
                
                if (steer.mag() > 0) {
                    steer.normalize();
                    steer.mult(MAX_SPEED);
                    steer.sub(this.vel);
                    steer.limit(MAX_FORCE * 2);
                }
                return steer;
            }

            update(particles, width, height) {
                let sep = this.separate(particles);
                let wan = this.wander();
                let bnd = this.edges(width, height);
                sep.mult(1.5);
                wan.mult(1.0);
                bnd.mult(2.0);
                this.applyForce(sep);
                this.applyForce(wan);
                this.applyForce(bnd);
                this.vel.add(this.acc);
                this.vel.limit(MAX_SPEED);
                this.pos.add(this.vel);
                this.acc.mult(0);
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, POINT_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = POINT_COLOR;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // --- SOLVER ---
        class Solver {
            constructor() {
                this.prevCoeffs = null;
                this.matrix = [];
                for (let i = 0; i < 9; i++) {
                    this.matrix.push(new Float64Array(10));
                }
                this.coeffsBuffer = new Float64Array(10);
            }

            solve(particles, width, height) {
                const cx = width / 2;
                const cy = height / 2;
                const scale = Math.min(width, height) / 2.5;

                // 1. Fill Matrix
                for (let i = 0; i < 9; i++) {
                    let p = particles[i];
                    let x = (p.pos.x - cx) / scale;
                    let y = (p.pos.y - cy) / scale;
                    
                    let row = this.matrix[i];
                    row[0] = x*x*x; row[1] = y*y*y; row[2] = x*x*y; row[3] = x*y*y;
                    row[4] = x*x;   row[5] = y*y;   row[6] = x*y;
                    row[7] = x;     row[8] = y;
                    row[9] = 1;
                }

                // 2. Gaussian Elimination
                const nRows = 9;
                const nCols = 10;
                let lead = 0;
                
                for (let r = 0; r < nRows; r++) {
                    if (nCols <= lead) break;
                    let i = r;
                    
                    while (this.matrix[i][lead] === 0) {
                        i++;
                        if (nRows === i) {
                            i = r;
                            lead++;
                            if (nCols === lead) return this.prevCoeffs;
                        }
                    }
                    
                    let temp = this.matrix[i];
                    this.matrix[i] = this.matrix[r];
                    this.matrix[r] = temp;
                    
                    let val = this.matrix[r][lead];
                    if (Math.abs(val) < 1e-9) return this.prevCoeffs;

                    for (let j = 0; j < nCols; j++) this.matrix[r][j] /= val;
                    
                    for (let k = 0; k < nRows; k++) {
                        if (k === r) continue;
                        val = this.matrix[k][lead];
                        for (let j = 0; j < nCols; j++) this.matrix[k][j] -= val * this.matrix[r][j];
                    }
                    lead++;
                }

                // 3. Extract Coefficients
                this.coeffsBuffer[9] = 1; 
                for (let i = nRows - 1; i >= 0; i--) {
                    this.coeffsBuffer[i] = -this.matrix[i][9]; 
                }

                // 4. Normalize
                let mag = 0;
                for(let c of this.coeffsBuffer) mag += c*c;
                mag = Math.sqrt(mag);
                for(let i=0; i<10; i++) this.coeffsBuffer[i] /= mag;

                // 5. Consistency Check
                if (this.prevCoeffs) {
                    let dot = 0;
                    for(let i=0; i<10; i++) dot += this.coeffsBuffer[i] * this.prevCoeffs[i];
                    if (dot < 0) {
                        for(let i=0; i<10; i++) this.coeffsBuffer[i] *= -1;
                    }
                }

                // Save for next frame
                if (!this.prevCoeffs) {
                    this.prevCoeffs = new Float32Array(10);
                }
                for(let i=0; i<10; i++) this.prevCoeffs[i] = this.coeffsBuffer[i];

                return this.prevCoeffs;
            }
        }

        // --- RENDERER ---
        const vsSource = `
            attribute vec4 aVertexPosition;
            void main() {
                gl_Position = aVertexPosition;
            }
        `;

        const fsSource = `
            #extension GL_OES_standard_derivatives : enable
            precision highp float;
            
            uniform vec2 u_resolution;
            uniform float u_scale;
            uniform float u_coeffs[10];
            uniform vec4 u_colPos;
            uniform vec4 u_colNeg;
            uniform vec4 u_colLine;

            void main() {
                float w = u_resolution.x;
                float h = u_resolution.y;
                float cx = w * 0.5;
                float cy = h * 0.5;
                float scale = u_scale;

                float pixelX = gl_FragCoord.x;
                float pixelY = h - gl_FragCoord.y;

                float x = (pixelX - cx) / scale;
                float y = (pixelY - cy) / scale;

                float x2 = x * x;
                float y2 = y * y;

                float val = u_coeffs[0]*x2*x + 
                            u_coeffs[1]*y2*y + 
                            u_coeffs[2]*x2*y + 
                            u_coeffs[3]*x*y2 + 
                            u_coeffs[4]*x2 + 
                            u_coeffs[5]*y2 + 
                            u_coeffs[6]*x*y + 
                            u_coeffs[7]*x + 
                            u_coeffs[8]*y + 
                            u_coeffs[9];

                vec4 color = (val > 0.0) ? u_colPos : u_colNeg;

                float d = abs(val) / (fwidth(val) + 0.00001);
                float lineThickness = 1.5; 
                float alpha = 1.0 - smoothstep(lineThickness - 1.0, lineThickness, d);
                
                gl_FragColor = mix(color, u_colLine, alpha);
            }
        `;

        class Renderer {
            constructor(gl) {
                this.gl = gl;
                this.programInfo = null;
                this.buffer = null;
                this.init();
            }

            init() {
                const gl = this.gl;
                gl.getExtension('OES_standard_derivatives');
                
                const shaderProgram = this.initShaderProgram(vsSource, fsSource);
                
                this.programInfo = {
                    program: shaderProgram,
                    attribLocations: {
                        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                    },
                    uniformLocations: {
                        resolution: gl.getUniformLocation(shaderProgram, 'u_resolution'),
                        scale: gl.getUniformLocation(shaderProgram, 'u_scale'),
                        coeffs: gl.getUniformLocation(shaderProgram, 'u_coeffs'),
                        colPos: gl.getUniformLocation(shaderProgram, 'u_colPos'),
                        colNeg: gl.getUniformLocation(shaderProgram, 'u_colNeg'),
                        colLine: gl.getUniformLocation(shaderProgram, 'u_colLine'),
                    },
                };
                
                this.buffer = this.initBuffers();
            }

            initShaderProgram(vs, fs) {
                const gl = this.gl;
                const vertexShader = this.loadShader(gl.VERTEX_SHADER, vs);
                const fragmentShader = this.loadShader(gl.FRAGMENT_SHADER, fs);
                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);
                
                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    console.error('Unable to initialize the shader program: ' + gl.getProgramInfoLog(shaderProgram));
                    return null;
                }
                return shaderProgram;
            }

            loadShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('An error occurred compiling the shaders: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            initBuffers() {
                const gl = this.gl;
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                const positions = [
                    -1.0,  1.0,
                     1.0,  1.0,
                    -1.0, -1.0,
                     1.0, -1.0,
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                return { position: positionBuffer };
            }

            draw(coeffs, width, height) {
                if (!coeffs) return;
                const gl = this.gl;
                const scale = Math.min(width, height) / 2.5;

                gl.useProgram(this.programInfo.program);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer.position);
                gl.vertexAttribPointer(this.programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexPosition);

                gl.uniform2f(this.programInfo.uniformLocations.resolution, width, height);
                gl.uniform1f(this.programInfo.uniformLocations.scale, scale);
                gl.uniform1fv(this.programInfo.uniformLocations.coeffs, coeffs);
                
                gl.uniform4fv(this.programInfo.uniformLocations.colPos, COLOR_POS);
                gl.uniform4fv(this.programInfo.uniformLocations.colNeg, COLOR_NEG);
                gl.uniform4fv(this.programInfo.uniformLocations.colLine, COLOR_LINE);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
        }

        // --- MAIN ---
        const glCanvas = document.getElementById('glCanvas');
        const uiCanvas = document.getElementById('uiCanvas');
        const gl = glCanvas.getContext('webgl');
        const ctx = uiCanvas.getContext('2d');

        let width, height;
        let particles = [];
        let solver;
        let renderer;

        function init() {
            renderer = new Renderer(gl);
            solver = new Solver();
            
            resize();
            window.addEventListener('resize', resize);
            
            particles = [];
            for (let i = 0; i < POINT_COUNT; i++) {
                let x = Math.random() * (width - 200) + 100;
                let y = Math.random() * (height - 200) + 100;
                particles.push(new Particle(x, y));
            }
            
            requestAnimationFrame(animate);
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            
            glCanvas.width = width;
            glCanvas.height = height;
            uiCanvas.width = width;
            uiCanvas.height = height;

            gl.viewport(0, 0, width, height);
        }

        function animate() {
            for (let p of particles) {
                p.update(particles, width, height);
            }

            ctx.clearRect(0, 0, width, height);
            for (let p of particles) {
                p.draw(ctx);
            }

            const coeffs = solver.solve(particles, width, height);
            if (coeffs) {
                renderer.draw(coeffs, width, height);
            }

            requestAnimationFrame(animate);
        }

        init();
    </script>
</body>
</html>