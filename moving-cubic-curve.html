<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Implicit Curve Regions</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #0f172a;
            font-family: sans-serif;
        }
        canvas {
            display: block;
            position: absolute;
            top: 0;
            left: 0;
        }
        #glCanvas {
            z-index: 0;
        }
        #uiCanvas {
            z-index: 1;
        }
    </style>
</head>
<body>
    <canvas id="glCanvas"></canvas>
    <canvas id="uiCanvas"></canvas>

    <script>
        // --- CONFIG ---
        let currentDegree = 3; 
        
        // Calculate required points: (D+1)(D+2)/2 - 1
        let termCount = ((currentDegree + 1) * (currentDegree + 2)) / 2;
        let pointCount = termCount - 1;
        
        const POINT_RADIUS = 6;
        
        // Dynamic Physics Factors (K constants)
        // Calculated based on sqrt(Area / N)
        const K_DIST = 0.22;   // Distance factor
        const K_SPEED = 0.0055; // Speed factor
        const K_FORCE = 0.06;   // Force factor relative to speed (Steering ability)

        const WANDER_STRENGTH = 0.1;

        const COLOR_POS = [30/255, 41/255, 59/255, 1.0]; 
        const COLOR_NEG = [15/255, 23/255, 42/255, 1.0];
        const COLOR_LINE = [45/255, 212/255, 191/255, 1.0];
        const POINT_COLOR = '#5eead4';

        // --- GLOBALS (Physics) ---
        let minDistance = 100;
        let maxSpeed = 2.5;
        let maxForce = 0.15;
        let isPaused = false;

        // --- VECTOR ---
        class Vector {
            constructor(x, y) { this.x = x; this.y = y; }
            set(x, y) { this.x = x; this.y = y; return this; }
            setVec(v) { this.x = v.x; this.y = v.y; return this; }
            add(v) { this.x += v.x; this.y += v.y; return this; }
            sub(v) { this.x -= v.x; this.y -= v.y; return this; }
            mult(n) { this.x *= n; this.y *= n; return this; }
            div(n) { if (n !== 0) { this.x /= n; this.y /= n; } return this; }
            mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
            normalize() { let m = this.mag(); if (m > 0) this.div(m); return this; }
            limit(max) { if (this.mag() > max) { this.normalize(); this.mult(max); } return this; }
            static dist(v1, v2) { let dx = v1.x - v2.x; let dy = v1.y - v2.y; return Math.sqrt(dx * dx + dy * dy); }
            static sub(v1, v2) { return new Vector(v1.x - v2.x, v1.y - v2.y); }
            copy() { return new Vector(this.x, this.y); }
        }

        // --- PARTICLE ---
        class Particle {
            constructor(x, y) {
                this.pos = new Vector(x, y);
                this.vel = new Vector(Math.random() * 2 - 1, Math.random() * 2 - 1);
                this.acc = new Vector(0, 0);
                this.wanderTheta = Math.random() * Math.PI * 2;
                
                this._steer = new Vector(0, 0);
                this._diff = new Vector(0, 0);
                this._circleCenter = new Vector(0, 0);
                this._displacement = new Vector(0, 0);
            }

            applyForce(force) { this.acc.add(force); }

            separate(particles) {
                let desiredseparation = minDistance;
                this._steer.set(0, 0);
                let count = 0;
                for (let other of particles) {
                    let d = Vector.dist(this.pos, other.pos);
                    if ((other !== this) && (d < desiredseparation)) {
                        this._diff.setVec(this.pos).sub(other.pos);
                        this._diff.normalize();
                        this._diff.div(d);
                        this._steer.add(this._diff);
                        count++;
                    }
                }
                if (count > 0) {
                    this._steer.div(count);
                    this._steer.normalize();
                    this._steer.mult(maxSpeed);
                    this._steer.sub(this.vel);
                    this._steer.limit(maxForce * 1.5);
                }
                return this._steer;
            }

            wander() {
                let wanderRange = 0.3;
                this.wanderTheta += (Math.random() * 2 - 1) * wanderRange;
                let wanderRadius = 25;
                let wanderDistance = 80;
                
                this._circleCenter.setVec(this.vel);
                this._circleCenter.normalize();
                this._circleCenter.mult(wanderDistance);
                
                this._displacement.set(0, -1);
                this._displacement.mult(wanderRadius);
                
                let h = this.wanderTheta;
                let x = this._displacement.x;
                let y = this._displacement.y;
                this._displacement.x = x * Math.cos(h) - y * Math.sin(h);
                this._displacement.y = x * Math.sin(h) + y * Math.cos(h);
                
                let target = this._circleCenter.add(this._displacement);
                target.limit(maxForce);
                return target;
            }

            edges(width, height) {
                let margin = 50;
                let steer = this._diff;
                steer.set(0, 0);
                
                if (this.pos.x < margin) steer.x = maxSpeed;
                if (this.pos.x > width - margin) steer.x = -maxSpeed;
                if (this.pos.y < margin) steer.y = maxSpeed;
                if (this.pos.y > height - margin) steer.y = -maxSpeed;
                
                if (steer.mag() > 0) {
                    steer.normalize();
                    steer.mult(maxSpeed);
                    steer.sub(this.vel);
                    steer.limit(maxForce * 2);
                }
                return steer;
            }

            update(particles, width, height) {
                let sep = this.separate(particles);
                let wan = this.wander();
                let bnd = this.edges(width, height);
                sep.mult(1.5);
                wan.mult(1.0);
                bnd.mult(2.0);
                this.applyForce(sep);
                this.applyForce(wan);
                this.applyForce(bnd);
                this.vel.add(this.acc);
                this.vel.limit(maxSpeed);
                this.pos.add(this.vel);
                this.acc.mult(0);
            }

            draw(ctx) {
                ctx.beginPath();
                ctx.arc(this.pos.x, this.pos.y, POINT_RADIUS, 0, Math.PI * 2);
                ctx.fillStyle = POINT_COLOR;
                ctx.fill();
                ctx.strokeStyle = 'white';
                ctx.lineWidth = 1;
                ctx.stroke();
            }
        }

        // --- SOLVER ---
        class Solver {
            constructor(degree) {
                this.degree = degree;
                this.terms = this.generateTerms(degree);
                this.termCount = this.terms.length;
                this.pointCount = this.termCount - 1;

                this.prevCoeffs = null;
                
                // Matrix: pointCount rows, termCount cols
                this.matrix = [];
                for (let i = 0; i < this.pointCount; i++) {
                    this.matrix.push(new Float64Array(this.termCount));
                }
                this.coeffsBuffer = new Float64Array(this.termCount);

                // State
                this.width = 1;
                this.height = 1;
                this.cx = 0.5;
                this.cy = 0.5;
                this.scale = 1;
            }

            resize(width, height) {
                this.width = width;
                this.height = height;
                this.cx = width / 2;
                this.cy = height / 2;
                this.scale = Math.min(width, height) / 2.5;
            }

            generateTerms(degree) {
                let terms = [];
                for (let d = degree; d >= 0; d--) {
                    for (let x = d; x >= 0; x--) {
                        let y = d - x;
                        terms.push({x, y});
                    }
                }
                return terms;
            }

            solve(particles) {
                if (particles.length !== this.pointCount) return null;

                // 1. Fill Matrix
                for (let i = 0; i < this.pointCount; i++) {
                    let p = particles[i];
                    let nx = (p.pos.x - this.cx) / this.scale;
                    let ny = (p.pos.y - this.cy) / this.scale;
                    
                    let row = this.matrix[i];
                    for (let j = 0; j < this.termCount; j++) {
                        let t = this.terms[j];
                        // Optimize pow: simple multiplications for small powers
                        let val = 1;
                        for(let k=0; k<t.x; k++) val *= nx;
                        for(let k=0; k<t.y; k++) val *= ny;
                        row[j] = val;
                    }
                }

                // 2. Gaussian Elimination
                const nRows = this.pointCount;
                const nCols = this.termCount;
                let lead = 0;
                
                for (let r = 0; r < nRows; r++) {
                    if (nCols <= lead) break;
                    let i = r;
                    
                    while (this.matrix[i][lead] === 0) {
                        i++;
                        if (nRows === i) {
                            i = r;
                            lead++;
                            if (nCols === lead) return this.prevCoeffs;
                        }
                    }
                    
                    let temp = this.matrix[i];
                    this.matrix[i] = this.matrix[r];
                    this.matrix[r] = temp;
                    
                    let val = this.matrix[r][lead];
                    if (Math.abs(val) < 1e-9) return this.prevCoeffs;

                    for (let j = 0; j < nCols; j++) this.matrix[r][j] /= val;
                    
                    for (let k = 0; k < nRows; k++) {
                        if (k === r) continue;
                        val = this.matrix[k][lead];
                        for (let j = 0; j < nCols; j++) this.matrix[k][j] -= val * this.matrix[r][j];
                    }
                    lead++;
                }

                // 3. Extract Coefficients
                this.coeffsBuffer[nCols - 1] = 1; 
                for (let i = nRows - 1; i >= 0; i--) {
                    this.coeffsBuffer[i] = -this.matrix[i][nCols - 1]; 
                }

                // 4. Normalize
                let mag = 0;
                for(let c of this.coeffsBuffer) mag += c*c;
                mag = Math.sqrt(mag);
                for(let i=0; i < nCols; i++) this.coeffsBuffer[i] /= mag;

                // 5. Consistency Check
                if (this.prevCoeffs) {
                    let dot = 0;
                    for(let i=0; i < nCols; i++) dot += this.coeffsBuffer[i] * this.prevCoeffs[i];
                    if (dot < 0) {
                        for(let i=0; i < nCols; i++) this.coeffsBuffer[i] *= -1;
                    }
                }

                // Save for next frame
                if (!this.prevCoeffs) {
                    this.prevCoeffs = new Float32Array(nCols);
                }
                for(let i=0; i < nCols; i++) this.prevCoeffs[i] = this.coeffsBuffer[i];

                return this.prevCoeffs;
            }
        }

        // --- RENDERER ---
        const vsSource = `
            attribute vec4 aVertexPosition;
            void main() {
                gl_Position = aVertexPosition;
            }
        `;

        class Renderer {
            constructor(gl, degree) {
                this.gl = gl;
                this.degree = degree;
                this.terms = this.generateTerms(degree);
                this.programInfo = null;
                this.buffer = null;
                
                this.width = 1;
                this.height = 1;
                this.scale = 1;

                this.init();
            }

            resize(width, height) {
                this.width = width;
                this.height = height;
                this.scale = Math.min(width, height) / 2.5;
                this.gl.viewport(0, 0, width, height);
            }

            generateTerms(degree) {
                let terms = [];
                for (let d = degree; d >= 0; d--) {
                    for (let x = d; x >= 0; x--) {
                        let y = d - x;
                        terms.push({x, y});
                    }
                }
                return terms;
            }

            generateFragShader() {
                const termCount = this.terms.length;
                let poly = "";
                
                for (let i = 0; i < termCount; i++) {
                    let t = this.terms[i];
                    let termStr = `u_coeffs[${i}]`;
                    
                    // Generate multiplications x*x...
                    for(let k=0; k<t.x; k++) termStr += "*x";
                    for(let k=0; k<t.y; k++) termStr += "*y";
                    
                    if (i > 0) poly += " + ";
                    poly += termStr;
                }

                return `
                    #extension GL_OES_standard_derivatives : enable
                    precision highp float;
                    
                    uniform vec2 u_resolution;
                    uniform float u_scale;
                    uniform float u_coeffs[${termCount}];
                    uniform vec4 u_colPos;
                    uniform vec4 u_colNeg;
                    uniform vec4 u_colLine;

                    void main() {
                        float w = u_resolution.x;
                        float h = u_resolution.y;
                        float cx = w * 0.5;
                        float cy = h * 0.5;
                        float scale = u_scale;

                        float pixelX = gl_FragCoord.x;
                        float pixelY = h - gl_FragCoord.y;

                        float x = (pixelX - cx) / scale;
                        float y = (pixelY - cy) / scale;

                        float val = ${poly};

                        vec4 color = (val > 0.0) ? u_colPos : u_colNeg;

                        float d = abs(val) / (fwidth(val) + 0.00001);
                        float lineThickness = 1.5; 
                        float alpha = 1.0 - smoothstep(lineThickness - 1.0, lineThickness, d);
                        
                        gl_FragColor = mix(color, u_colLine, alpha);
                    }
                `;
            }

            init() {
                const gl = this.gl;
                gl.getExtension('OES_standard_derivatives');
                
                const fsSource = this.generateFragShader();
                const shaderProgram = this.initShaderProgram(vsSource, fsSource);
                
                this.programInfo = {
                    program: shaderProgram,
                    attribLocations: {
                        vertexPosition: gl.getAttribLocation(shaderProgram, 'aVertexPosition'),
                    },
                    uniformLocations: {
                        resolution: gl.getUniformLocation(shaderProgram, 'u_resolution'),
                        scale: gl.getUniformLocation(shaderProgram, 'u_scale'),
                        coeffs: gl.getUniformLocation(shaderProgram, 'u_coeffs'),
                        colPos: gl.getUniformLocation(shaderProgram, 'u_colPos'),
                        colNeg: gl.getUniformLocation(shaderProgram, 'u_colNeg'),
                        colLine: gl.getUniformLocation(shaderProgram, 'u_colLine'),
                    },
                };
                
                this.buffer = this.initBuffers();
            }

            initShaderProgram(vs, fs) {
                const gl = this.gl;
                const vertexShader = this.loadShader(gl.VERTEX_SHADER, vs);
                const fragmentShader = this.loadShader(gl.FRAGMENT_SHADER, fs);
                const shaderProgram = gl.createProgram();
                gl.attachShader(shaderProgram, vertexShader);
                gl.attachShader(shaderProgram, fragmentShader);
                gl.linkProgram(shaderProgram);
                
                if (!gl.getProgramParameter(shaderProgram, gl.LINK_STATUS)) {
                    console.error('Shader Link Error: ' + gl.getProgramInfoLog(shaderProgram));
                    return null;
                }
                return shaderProgram;
            }

            loadShader(type, source) {
                const gl = this.gl;
                const shader = gl.createShader(type);
                gl.shaderSource(shader, source);
                gl.compileShader(shader);
                
                if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS)) {
                    console.error('Shader Compile Error: ' + gl.getShaderInfoLog(shader));
                    gl.deleteShader(shader);
                    return null;
                }
                return shader;
            }

            initBuffers() {
                const gl = this.gl;
                const positionBuffer = gl.createBuffer();
                gl.bindBuffer(gl.ARRAY_BUFFER, positionBuffer);
                const positions = [
                    -1.0,  1.0,
                     1.0,  1.0,
                    -1.0, -1.0,
                     1.0, -1.0,
                ];
                gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(positions), gl.STATIC_DRAW);
                return { position: positionBuffer };
            }

            draw(coeffs) {
                if (!coeffs) return;
                const gl = this.gl;

                gl.useProgram(this.programInfo.program);

                gl.bindBuffer(gl.ARRAY_BUFFER, this.buffer.position);
                gl.vertexAttribPointer(this.programInfo.attribLocations.vertexPosition, 2, gl.FLOAT, false, 0, 0);
                gl.enableVertexAttribArray(this.programInfo.attribLocations.vertexPosition);

                gl.uniform2f(this.programInfo.uniformLocations.resolution, this.width, this.height);
                gl.uniform1f(this.programInfo.uniformLocations.scale, this.scale);
                gl.uniform1fv(this.programInfo.uniformLocations.coeffs, coeffs);
                
                gl.uniform4fv(this.programInfo.uniformLocations.colPos, COLOR_POS);
                gl.uniform4fv(this.programInfo.uniformLocations.colNeg, COLOR_NEG);
                gl.uniform4fv(this.programInfo.uniformLocations.colLine, COLOR_LINE);

                gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
            }
        }

        // --- MAIN ---
        const glCanvas = document.getElementById('glCanvas');
        const uiCanvas = document.getElementById('uiCanvas');
        const gl = glCanvas.getContext('webgl');
        const ctx = uiCanvas.getContext('2d');

        let width, height;
        let particles = [];
        let solver;
        let renderer;

        function spawnParticles() {
            particles = [];
            const margin = minDistance; 
            for (let i = 0; i < pointCount; i++) {
                let x = Math.random() * (width - margin * 2) + margin;
                let y = Math.random() * (height - margin * 2) + margin;
                particles.push(new Particle(x, y));
            }
        }

        function setDegree(newDegree) {
            if (newDegree < 1 || newDegree > 6) return;
            currentDegree = newDegree;
            termCount = ((currentDegree + 1) * (currentDegree + 2)) / 2;
            pointCount = termCount - 1;

            solver = new Solver(currentDegree);
            renderer = new Renderer(gl, currentDegree);
            
            // Recalculate physics and spawn
            resize(); 
            spawnParticles();
        }

        function init() {
            solver = new Solver(currentDegree);
            renderer = new Renderer(gl, currentDegree);
            
            resize();
            window.addEventListener('resize', resize);
            window.addEventListener('keydown', (e) => {
                if (e.key === ' ') {
                    isPaused = !isPaused;
                }
                if (e.key === 'r' || e.key === 'R') {
                    spawnParticles();
                }
                if (e.key === 'ArrowUp') {
                    setDegree(currentDegree + 1);
                }
                if (e.key === 'ArrowDown') {
                    setDegree(currentDegree - 1);
                }
            });
            
            spawnParticles();
            
            requestAnimationFrame(animate);
        }

        function resize() {
            width = window.innerWidth;
            height = window.innerHeight;
            
            glCanvas.width = width;
            glCanvas.height = height;
            uiCanvas.width = width;
            uiCanvas.height = height;

            // Update Physics Globals
            const areaPerPoint = (width * height) / pointCount;
            const baseScale = Math.sqrt(areaPerPoint);
            
            minDistance = baseScale * K_DIST;
            maxSpeed = baseScale * K_SPEED;
            maxForce = maxSpeed * K_FORCE; // Force relative to speed

            // Notify systems
            if (solver) solver.resize(width, height);
            if (renderer) renderer.resize(width, height);
        }

        function animate() {
            if (!isPaused) {
                for (let p of particles) {
                    p.update(particles, width, height);
                }
            }

            ctx.clearRect(0, 0, width, height);
            for (let p of particles) {
                p.draw(ctx);
            }

            const coeffs = solver.solve(particles);
            if (coeffs) {
                renderer.draw(coeffs);
            }

            requestAnimationFrame(animate);
        }

        init();
    </script>
</body>
</html>